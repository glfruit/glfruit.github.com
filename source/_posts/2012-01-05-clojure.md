---
layout: post
title: "Clojure的基本原理"
date: 2012-01-05 14:29
categories: 技术研究
tags: [Clojure]
---

基本原理


客户和干系人都对诸如JVM这样的行业标准平台的性能、安全性以及稳定性进行了大量的投资，并且对其感到满意。虽然Java开发者可能会对动态语言的简洁、灵活及生产力感到嫉妒，但是他们要考虑在客户允许的基础结构上运行、访问已有的代码库以及性能等方面的问题。除此之外，他们还要使用原生线程和加锁来面对涉及到并发的问题。Clojure就是在这样一种背景下所做的一个实用动态语言设计的努力。它致力于成为一种适用于Java所使用的那些领域。它反映出了未来的并发编程的事实，即，普遍的、不会减速的变化必然会到来。 
Clojure通过以下几点来达到它的目的： 

* 拥抱行业标准的开发平台——JVM
* 对一门值得尊敬的语言——Lisp进行现代化改造
* 通过不变的持久化数据结构来鼓励函数式编程
* 通过软件事务内存和异步代理提供内建的并发支持


我们最终得到的是一个强健、实用而快速的结果。 
为什么要使用Clojure？


我为什么还要再编写一门程序语言？大体而言，因为我想要： 

* 一种Lisp
* 函数式编程
* 和一个已稳固确立的平台共生
* 为并发而设计


但是我却没有找到这样一种语言。下面是对Clojure背后的一些动机的概述： 


* Lisp是个好东西
* 经常被模仿/洗劫，但是仍未被复制
* Lambda演算导致一个非常小的核心
* 几乎没有语法
* 核心优势仍然是代码即数据以及语法抽象
* 标准的Lisp（Common Lisp和Scheme）
* 标准化之后缓慢/没有革新
* 核心的数据结构是可变的，并且不可扩展
* 规范中没有涉及到并发
* JVM上已经有了良好的实现（ABCL，Kawa，SISC等）
* 标准的Lisp自身即是一个平台


Clojure是一种没有向后兼容性约束的Lisp


将“代码即数据”的范式推广到了map和vector

默认数据是不可改变的

核心的数据结构是可扩展的抽象

拥抱了一个平台（JVM）





函数式编程是个好东西


数据不可变+函数为一等“公民”

总是能够根据行规/惯例用Lisp完成


但是如果数据结构是可变的，那么假设数据不会被改变是很危险的事情

在传统的Lisp中，只有list数据结构在结构上才是可递归的


纯粹的函数式语言总是倾向于强静态类型


并非对每个人、每个任务都合适


Clojure是一种强调动态性的函数式语言


所有的数据都不可变&可持久化，且支持递归

不同类型的集合、返回类型

动态的多态



语言和平台


虚拟机，而不是操作系统，才是未来的平台，它提供了：


类型系统


动态执行和安全性


库


抽象了OS

大量的工具

内建和第三方


内存及其它资源管理


GC是一个平台，而不是语言、工具


字节码+JIT编译


抽象了硬件


语言即平台 vs 语言+平台


老的方式——每种语言定义自己的运行时


GC、字节码、类型系统、库等


新的方式（JVM，.NET）


独立于语言的通用运行时



为平台构建的语言 vs 移植到平台的语言


许多新的语言仍然采用“语言即平台”的方式

移植时存在着 平台到平台的问题


内存管理、类型系统、线程问题

重复的库

如果原来的语言基于C的话，一些用C写的扩展库并未移植过来



平台是由客户指定的


必须运行在JVM或.NET上 vs 必须运行在Unix或Windows上

JVM已经建立了追踪记录和信任级别


现在也已经开源了


需要和其它代码交互


现在光有C的连接是不够的


Java/JVM是语言+平台


Java


Clojure是语言，JVM是平台




OO被高估了


起源于模仿，如今用于每个地方，即使不合适


多态是个好东西


Switch语句、结构匹配等导致脆弱的系统

多态可以带来灵活的、可扩展的系统

Clojure的多方法机制将多态与OO和类型分离开来


支持多种分类

通过静态、动态、外部属性、元数据等方式进行派发



并发及多核未来


不可变性让许多问题都消失了


可以自由地在线程之间共享




简而言之，我认为Clojure作为JVM上一种对并发有很强支持的、能够实际运行的Lisp占据了一个独特的位置。看看Clojure的一些特点。

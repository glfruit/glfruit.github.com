---
layout: post
title: "Clojure的基本理念"
date: 2012-01-05 14:29
categories: 技术研究
tags: [Clojure]
---

## Clojure的基本理念

客户和相关人员都对诸如JVM这样的行业标准平台的性能、安全性以及稳定性进行了大量投资，并且对其感到满意。虽然Java开发者可能会对动态语言的简洁、灵活性及生产力感到嫉妒，但是他们要考虑在客户允许的基础结构上运行、访问已有的代码库以及性能等方面的问题。除此之外，他们还要面对使用原生线程和加锁处理并发时所持续不断出现的问题。Clojure就是在这样一种背景下所做出的实用动态语言设计的努力。它致力于成为一种Java所适用的那些领域中的通用语言。它反映出了一个现实，对于并发编程来说，现在普遍存在的、不受约束的状态变化必然会消失。 

Clojure通过以下几点来达到它的目的： 

* 拥抱行业标准的开发平台——JVM
* 对一门值得尊敬的语言——Lisp进行现代化改造
* 通过不变的持久化数据结构来促进函数式编程
* 通过软件事务内存和异步代理提供内建的并发支持

我们最终得到的是一门健壮、实用而快速的语言。 

Clojure对于状态和同一性采取了一种与众不同的方式。

## 为什么要使用Clojure？


我为什么还要再编写一门程序语言？大体而言，因为我想要： 

* 一种Lisp
* 函数式编程
* 和一个已稳固确立的平台共生
* 为并发而设计


但是我却没有找到这样一种语言。下面是对Clojure背后的一些动机的概述： 

## Lisp是个好东西


* 经常被模仿/洗劫，但是仍未被复制
* Lambda演算产生出一个非常小的核心
* 几乎没有语法
* 核心优势仍然是代码即数据以及语法抽象
* 标准的Lisp（Common Lisp和Scheme）

  * 标准化之后缓慢/没有革新
  * 核心的数据结构是可变的，并且不可扩展
  * 规范中没有涉及到并发
  * JVM上已经有了良好的实现（ABCL，Kawa，SISC等）
  * 标准的Lisp自身即是一个平台

- Clojure是一种没有向后兼容性约束的Lisp
  - 将“代码即数据”的范式推广到了map和vector

  - 默认数据是不可改变的
  - 核心的数据结构是可扩展的抽象
  - 拥抱平台（JVM）

## 函数式编程是个好东西

- 数据不可变+函数为一等“公民”

- 总是能够根据行规/惯例用Lisp完成
  - 但是如果数据结构是可变的，那么假设数据不会被改变是很危险的事情
  - 在传统的Lisp中，只有list数据结构在结构上才是可递归的

- 纯粹的函数式语言总是倾向于强静态类型
  - 并非对每个人、每个任务都合适

- Clojure是一种强调动态性的函数式语言
  - 所有的数据都不可变&可持久化，且支持递归
  - 不同类型的集合、返回类型
  - 动态的多态

## 语言和平台

- 虚拟机，而不是操作系统，才是未来的平台，它提供了：
  - 类型系统
    - 动态执行和安全性
  - 库
    - 抽象了OS
    - 大量的工具
    - 内建和第三方
  - 内存及其它资源管理
    - GC是一个平台，而不是语言、工具
  - 字节码+JIT编译
    - 硬件抽象

- 语言即平台 vs 语言+平台
  - 老的方式——每种语言定义自己的运行时
    - GC、字节码、类型系统、库等
  - 新的方式（JVM，.NET）
    - 独立于语言的通用运行时

- 为平台构建的语言 vs 移植到平台的语言
  - 许多新的语言仍然采用“语言即平台”的方式
  - 移植时存在着 平台到平台的问题
    - 内存管理、类型系统、线程问题
    - 重复的库
    - 如果原来的语言基于C的话，一些用C写的扩展库并未移植过来

- 平台是由客户指定的
  - 必须运行在JVM或.NET上 vs 必须运行在Unix或Windows上
  - JVM已经建立了追踪记录和信任级别
    - 现在也已经开源了
  - 需要和其它代码交互
    - 现在光有C的连接是不够的

- Java/JVM是语言+平台
  - Java
- Clojure是语言，JVM是平台

## OO被高估了


起源于模仿，如今用于每个地方，即使不合适


多态是个好东西


Switch语句、结构匹配等导致脆弱的系统

多态可以带来灵活的、可扩展的系统

Clojure的多方法机制将多态与OO和类型分离开来


支持多种分类

通过静态、动态、外部属性、元数据等方式进行派发

## 多态是好东西

- switch语句、结构化匹配等产生出脆弱的系统
- 多态产生出可扩展的灵活系统
- Clojure的multimethod将多态与OO和类型解耦
  - 支持多重分类法
  - 通过静态、动态或者外部属性、原数据等分发消息

## 并发及多核未来

- 不变性让许多问题都消失了
  - 在线程间自由共享
- 对于模拟和程序与外部世界之间的代理来说，状态改变是一个现实
- 上锁（locking）非常困难，不可能每次都能正确实现
- Clojure的软件事务内存（software transaction memory）和代理系统（agent system）解决了困难的地方


简而言之，我认为Clojure作为JVM上一种对并发有很强支持的、能够实际运行的Lisp占据了一个独特的位置。看看Clojure的一些[特点](https://clojure.org/about/features)或者[开始使用Clojure](https://clojure.org/guides/getting_started)。
